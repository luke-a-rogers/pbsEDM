---
title: "Inclusion Issue Version 4 (new rEDM Simplex() to compare as in version 3, but simplifying down)"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{inclusion_issue_4}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 5,
  fig.height = 5
)
options(rmarkdown.html_vignette.check_title = FALSE)
```

```{r setup}
library(pbsEDM)
```

## Introduction

This vignette demonstrates the issue we found with
calculations in the `rEDM` package, namely to do with the nearest neighbours
that are used in the projection calculations. The calculations here use our
`pbsEDM` package led by Luke Rogers, and are verified using manual code written
independently by Andrew Edwards. <!-- See our manuscript for a full explanation. -->

The tibble `NY_lags_example_3` is saved in the package and contains a simple
simulated population time
series $N_t$ as `Nt`, with $t = 1, 2, 3, ..., 99, 100$. It also contains the
lagged values $N_{t-1}$ as `Ntmin1`, and first differences $Y_t = N_{t+1} - N_t$
as `Y_t`, with lagged values $Y_{t-1}$ as `Y_tmin1` and $Y_{t-2}$ as `Y_tmin2`. Also
included are EDM results for embedding dimension 2, using `rEDM::Simplex()` (`rEDM.pred`
for the predicted value and `rEDM.var` for its variance) and results from Andrew's original
function `EDM_pred_E_2()` (saved as `my.pred` and `my.var`). The code used to
run `rEDM::Simplex()` is repeated here, but not run (to avoid our `pbsEDM`
package being dependent on the `rEDM` package, to keep dependencies to a minimum.
See `?NY_lags_example_3` for full details. THE HELP WILL NEED UPDATING.


Can delete:
Using data saved in `Nx_lags_orig_3.R`, which used `rEDM::Simplex()`, whereas
vignette `inclusion_issue_2.Rmd` used `rEDM::simplex()` which is deprecated but
threw up a few more different answers. At some point simplify these all down.

Can delete:
Only saved data object that changed in `Nx_lags_orig_3.R` is `NY_lags_example_3`
(others are my results) so here replace `NY_lags_example` with `NY_lags_example_3` but can leave the
rest the same. NOW refers to text annotations here for differences with earlier version.



<!-- Change what's below based on
edm-work/code/simulated/sockeye-simulated/sockeye-sim-edm.Snw - has the movie
edm-work/code/simulated/egDeyle/egDeyle.rnw (that I used for different tstar,
for EAFMWG Jan 2020 I used egDeyleT95tstar15.rnw - can generalise once get
going here.
edm-work/code/simulated/egDeyle/tstarLoop/tstarLoop2019.rnw
and
edm-work/code/simulated/egDeyle/tstarLoop/mwe-2019.r
-->

Here are example results (for helping explain some of the later text):
```{r fullresults}
as.data.frame(head(NY_lags_example_3))
as.data.frame(tail(NY_lags_example_3))
```

This is the code to check that `rEDM::Simplex()` gives the stated results, but
it is not run (is just shown) in this vignette to avoid `pbsEDM` being dependent
on `rEDM` (and its dependencies). Can be used to simply check future versions of
both packages.
```{r compareredm, eval=FALSE}
input <-  dplyr::select(NY_lags_example_3, t, Y_t) %>%
  dplyr::rename(Time = t)

check_rEDM <- rEDM::Simplex(dataFrame = input,
                            columns = "Y_t",
                            target = "Y_t",
                            lib = "1 99",
                            pred = "1 99",
                            E = 2,
                            verbose = TRUE)$Predictions
check_rEDM <- c(NA,
                check_rEDM)   # Needs extra NA to get indexing correct

testthat::expect_equal(NY_lags_example_3$rEDM.pred,
                       check_rEDM)
```


Note that (TODO: mention this if it's part of the GitHub Issue):
```{r}
NY_lags_example_3[100, c("rEDM.pred", "my.pred")]
```
such that `rEDM` does not predict $Y_{100} = Y_{101} - Y_{100}$, but that is the
value we want so that we can predict $N_{101}$.
We should be able to predict it because we have all the relevent
information. THIS IS FIXED NOW IN rEDM.

<!-- Plot of data (before making movie):
Commenting out since not really needed (and have better function now
demonstrated in the vignette analyse_simple_time_series, though the code here
compares results in the final panel.
```{r, eval=FALSE}
plotPanelMovie.df2(only.final.plot=TRUE,
                   open.pdf=FALSE)

# ```{r, animation.hook = 'gifski', interval = 1.5}
# Cannot change fig.width and fig.height hooks unless re-order par() in function
# fig.width is 0.67 * fig.height
#```{r, eval=FALSE}
 for(i in 1:nrow(NY_lags_example_3))
  {
    plotPanelMovie.df2(end = i,
                       max_time = max(NY_lags_example_3$t),
                       only.final.plot=TRUE,
                       open.pdf=FALSE)
  }
# ```
```
-->

## Predictions using pbsEDM code

Now use the new `pbsEDM` code that Luke wrote independently; see the
[`analyse_simple_time_series`](analyse_simple_time_series.html) vignette for details on
using it. Then compare `pbsEDM` results with those from `rEDM` and from Andy's manual code:
```{r pbsEDMcalc}
pbs_calc <- pbsEDM(NY_lags_example_3,
                   lags = list(Y_t = c(0:1))) # A tibble (contains lists)

testthat::expect_equal(NY_lags_example_3$Y_t,
                       pbs_calc$X_observed[-length(pbs_calc$X_observed)])
                       # verifying the indexing is the same because X_observed has an extra NA value
                       # to match pbs_calc$X_forecast (to allow for forecasts of unlagged data)

pbs_pred <- pbs_calc$X_forecast[-length(pbs_calc$X_forecast)]

testthat::expect_equal(NY_lags_example_3$my.pred,
                       pbs_pred)
```
That last line will cause an error if the `pbsEDM` results do not match the
`my.pred` values from Andy's manual code.

Now to plot the `pbsEDM` predictions again those from `rEDM`:
```{r pbsredm}
plot(NY_lags_example_3$rEDM.pred,
     pbs_pred,
     xlab = "rEDM predictions",
     ylab = "pbsEDM predictions")
abline(a=0,
       b=1,
       col="grey")

# Colour in red the ones more than eps away
eps = 0.00001      # How different the predictions can be

# Want to compare new pbsEDM results with saved rEDM
NY_lags_extended <- dplyr::mutate(NY_lags_example_3,
                                  pbsEDM.pred = pbs_pred)

different <- dplyr::filter(NY_lags_extended,
                           abs(rEDM.pred - pbsEDM.pred) > eps)
points(different$rEDM.pred,
       different$my.pred,
       col = "red",
       pch = 20)

as.data.frame(different)
# Just time, observations Y_5, and predictions (my.pred is Andy's manual
# calculations):
dplyr::select(different, t, Y_t, rEDM.pred, my.pred, pbsEDM.pred)
```

**Conclusion**: Andy's original manual calculations and Luke's new function in
`pbsEDM` give the same results for this simulated data set, which differs for
three time values MORE NOW from
results from `rEDM`. Andy's and Luke's code was written independently, although
Andy had explained the issue as to why results differed to those from `rEDM`.
This is a reassuring test of Luke's new code, which is more
general and functionalised than Andy's, and can do more than just $E=2$.

## Explaining the issue

Vector $\bf{x}_t$ is the vector of lagged values of the
scalars $Y_t$:
$$\bf{x}_t = [Y_t, ~Y_{t-1}].$$
For focal time $t^*$, we know $\bf{x}_{t^*}$ and are trying to predict
$\bf{x}_{t^*+1}$. The issue is that `rEDM` seems to use $\bf{x}_{t^*+2}$ as a
nearest neighbour, but this should not be permissible.

For example, for $t^*=94$, Andy's R code calculates nearest neighbours with indices $\psi$
(saved as `psivec94`) and corresponding weights `weights94`:
```{r psi}
psivec94 = c(6, 57, 88)
weights94 = c(0.3678794, 0.3205861, 0.2895013)
```
giving the estimate of $Y_{95}$, from [S1] of Deyle et al. (2013), as
```{r Yninetyfive}
Y95est = sum(weights94 * simple_ts[psivec94+1]) / sum(weights94)
Y95est
```

The `pbsEDM` code gives the same results:
```{r}
pbs_calc$neighbour_index[94, ]
pbs_calc$neighbour_weight[94, ]
pbs_calc$X_forecast[95]
```
The following will give errors if those results don't agree):
```{r test}
testthat::expect_equal(psivec94, pbs_calc$neighbour_index[94, ])
testthat::expect_equal(weights94, pbs_calc$neighbour_weight[94, ], tolerance = 0.000001)
testthat::expect_equal(Y95est, pbs_calc$X_forecast[95])
```
However, `rEDM` gives

```{r rEDMninetyfive}
Y95est_rEDM = NY_lags_example_3$rEDM.pred[95]
Y95est_rEDM
```
as already noted above.

TODO: show rEDM full results. Can't find them now though.

## Manually reproduce `rEDM` result

We can reproduce the `rEDM` result by adapting Andy's manual code to allow
$\bf{x}_{96}$ to be a nearest neighbour of $\bf{x}_{94}$,  giving
```{r psi94allow}
psivec94_allow = c(96, 6, 57)   # so 6 and 57 are now 2nd and 3rd nearest neighbours
weights94_allow = c(3.678794e-01, 1.405278e-04, 4.146457e-05)
# Note that the first weight is the same as above (by definition it's always
#  exp(-1)), but the second and third are very small because x[96] is
#  very close to x[94].
Y95est_allow = sum(weights94_allow * simple_ts[psivec94_allow+1]) /
                   sum(weights94_allow)
Y95est_allow
```

However, the problem is that we should not be allowed to use $\bf{x}_{96}$. For
our focal time $t^* = 94$ we are trying to predict $Y_{t^*+1} = Y_{95}$. But, by
definition, $Y_{95}$ is included in $\bf{x}_{96}$ since
$$\bf{x}_{96} = [Y_{96}, Y_{95}].$$

So $\bf{x}_{96}$ should not be used to forecast $\bf{x}_{95}$, because it
explicitly contains one of the two components of $\bf{x}_{95}$ (namely the
$Y_{95}$ value that we are trying to predict).

The same issue occurs (with Andy's manual code) for $t^*=75$, for which Luke's code
gives the same answer as shown above (because all values give the same answer).

So the implementation of `rEDM` is not taking into account the fact that
$\bf{x}_t$ is a vector of lagged values.

## Try alternative settings for `rEDM`

## Another (old) attempt with `rEDM` - can probably delete

Andy tried the following in `rEDM`, to not allow $Y_{96}$ to be a nearest neighbour
predicting $Y_{95}$ from $Y_{94}$ -- but think this isn't possible, since it still
kind of wants cross-validation. Had played with `lib` and `pred` but couldn't get answer
to agree with Andy's original one. Not running
this in vignette, keeping for reference if needed:
```{r rEDMagain, eval=FALSE}
simp_Efix2 = simplex(simple_ts,
                     E = 2,
                     stats_only = FALSE,
                     # lib = matrix(c(1, 94, 97, 99), nrow = 2, byrow = TRUE),
                     lib = c(1, 94),
                     pred = c(95, 97)
                     # pred = matrix(c(95, 95, 96, 96), nrow = 2, byrow = TRUE)
                     )
rEDM_points2 = simp_Efix2[,"model_output"][[1]]       # time, obs, pred and pred_var
# Make each row correspond to t:
# rEDM_points2 = rbind(c(1, simple_ts[1], NA, NA), rEDM_points2) - only if doing all times
head(rEDM_points2)
```
